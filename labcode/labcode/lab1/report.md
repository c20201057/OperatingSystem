# Lab1
## 一、练习1
当操作系统刚从 Bootloader 跳转到内核时，CPU 进入的是内核的入口地址即kern_entry。  

此时，栈指针（sp）还未初始化，指向的是不确定的地址；C 语言环境（例如栈）都还未准备好。所以内核一开始必须用汇编手动设置好这些基础环境。  

`la sp, bootstacktop`的作用是将内核栈顶地址加载到栈指针寄存器 sp 中。目的是为内核建立初始栈，准备进入 C 语言环境。

`tail kern_init`的作用是 CPU 跳转到 kern_init 的地址继续执行，并且不会保存返回地址。尾调用和正常调用的区别就在这里，其是基于不返回而用到的优化。目的是进入内核 C 语言初始化函数，开始执行内核主逻辑。

总的来说，`la sp, bootstacktop` 为内核设置好启动时的栈，`tail kern_init` 把控制权转交给内核的 C 初始化函数，从此开始整个操作系统的正式启动流程。

## 二、练习2
### 1.调试过程及观察结果
首先，我们运行命令make debug启动qemu，然后在另一个终端运行make gdb启动gdb进行调试。

我们在gdb界面输入`x/5i $pc`，查看即将执行的5条汇编指令。得到结果如下：
```assembly
   0x1000:      auipc   t0,0x0
   0x1004:      addi    a1,t0,32
   0x1008:      csrr    a0,mhartid
   0x100c:      ld      t0,24(t0)
   0x1010:      jr      t0
```
这些指令会在下面练习回答部分解释，这里不再赘述。

输入`si`单步执行，使用`info r t0`指令查看寄存器t0的值：

```assembly
(gdb) si
0x0000000000001004 in ?? ()
(gdb) info r t0
t0             0x1000   4096
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) si
0x0000000000001010 in ?? ()
(gdb) info r t0
t0             0x80000000       2147483648
(gdb) si
0x0000000080000000 in ?? ()
 
```
可以看到t0的值在执行地址*0x100c*处的指令后发生了变化，从0x1000变成了0x80000000，因为执行了指令`ld t0,24(t0)`，从t0+24地址处读取了8个字节，存入寄存器t0。

之后会跳转到地址*0x80000000*处继续执行，输入`x/10i 0x80000000`，用于查看从地址 *0x80000000* 开始的 10 条指令。该地址处加载的是作为bootloader的OpenSBI.bin，该处的作用为加载操作系统内核并启动操作系统的执行。代码及解释如下：

```assembly
0x80000000: csrr a6,mhartid             # 读取当前硬件线程(hart)的编号到 a6 寄存器
0x80000004: bgtz a6,0x80000108          # 如果 a6 > 0，则跳转到0x80000108
0x80000008: auipc t0,0x0                # t0 = pc + (0x0 << 12) = 0x80000008
0x8000000c: addi t0,t0,1032             # t0 = t0 + 1032 = 0x80000418
0x80000010: auipc t1,0x0                # t1 = pc + (0x0 << 12) = 0x80000010
0x80000014: addi t1,t1,-16              # t1 = t1 - 16 = 0x80000000
0x80000018: sd t1,0(t0)                 # 把 t1 的值（0x80000000）存入内存[t0]
0x8000001c: auipc t0,0x0                # t0 = pc + (0x0 << 12) = 0x8000001c
0x80000020: addi t0,t0,1020             # t0 = t0 + 1020 = 0x80000420
0x80000024: ld t0,0(t0)                 # 从内存[0x80000420] 处加载一个 64 位值到 t0
```

接着输入指令`b* kern_entry`，在`<kern_entry>`的入口地址处设置断点，输出如下：

```assembly
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
```

<kern_entry> 是内核的汇编入口点，它负责完成内核启动前的最后一段汇编初始化工作（例如设置栈指针等），随后跳转到 C 语言编写的 kern_init 函数，开始执行真正的内核初始化流程。

之所以入口地址是 *0x80200000*，是因为在链接脚本（kernel.ld）中通过BASE_ADDRESS指定了内核的加载基地址：

输入指令`x/5i 0x80200000`，汇编代码及解释如下：

```assembly
   0x80200000 <kern_entry>:     auipc   sp,0x3                      #sp = 0x80200000 + 0x3000 = 0x80203000
   0x80200004 <kern_entry+4>:   mv      sp,sp                       #实际什么都没做（保持 sp 不变）             
   0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>      #无条件跳转到 0x8020000a (kern_init)
   0x8020000a <kern_init>:      auipc   a0,0x3                      #a0 = 0x8020000a + 0x3000 = 0x8020300a              
   0x8020000e <kern_init+4>:    addi    a0,a0,-2                    # a0 = a0 - 2 = 0x80203008
```

可以看到在`kern_entry`之后，紧接着就是`kern_init`

输入`continue`执行直到断点，debug输出如下：

```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
```
这说明OpenSBI此时已经启动。

接着输入指令`b* kern_init`，在 `<kern_init>` 的入口地址处设置一个断点,输出如下：

```assembly
Breakpoint 2 at 0x8020000a: file kern/init/init.c, line 8.
```

说明`<kern_init>`的入口地址是*0x8020000a*。

输入`continue`，接着输入`disassemble kern_init`查看反汇编代码：

```assembly
   0x000000008020000a <+0>:     auipc   a0,0x3                    # a0 = 0x8020000a + 0x3000 = 0x8020300a
   0x000000008020000e <+4>:     addi    a0,a0,-2                  #a0 = 0x8020300a - 2 = 0x80203008     
   0x0000000080200012 <+8>:     auipc   a2,0x3                    #a2 = 0x80200012 + 0x3000 = 0x80203012
   0x0000000080200016 <+12>:    addi    a2,a2,-10                 #a2 = 0x80203012 - 10 = 0x80203008
   0x000000008020001a <+16>:    addi    sp,sp,-16                 #sp = sp - 16
   0x000000008020001c <+18>:    li      a1,0                      #a1 = 0
   0x000000008020001e <+20>:    sub     a2,a2,a0                  #a2 = 0x80203008 - 0x80203008 = 0
   0x0000000080200020 <+22>:    sd      ra,8(sp)                  # *(sp + 8) = ra
   0x0000000080200022 <+24>:    jal     ra,0x802004b6 <memset>    #跳转到 memset 并把返回地址保存到 ra
   0x0000000080200026 <+28>:    auipc   a1,0x0                    #a1 = pc + (0x0 << 12) = pc = 0x80200026
   0x000000008020002a <+32>:    addi    a1,a1,1186                #a1 = 0x80200026 + 0x4A2 = 0x802004C8
   0x000000008020002e <+36>:    auipc   a0,0x0                    #a0 = 0x8020002e + 0x4BA = 0x802004E8
   0x0000000080200032 <+40>:    addi    a0,a0,1210                #a0 = 0x8020002e + 0x4BA = 0x802004E8
   0x0000000080200036 <+44>:    jal     ra,0x80200056 <cprintf>   #跳转到cprintf函数，并设置返回地址(ra)
   0x000000008020003a <+48>:    j       0x8020003a <kern_init+48> #无条件跳转到自身，形成死循环
```

可以看到这个函数最后一个指令是`j 0x8020003c <kern_init+48>`，也就是跳转到自己，所以代码会在这里一直循环下去。

输入`continue`，debug窗口出现以下输出：

```
(THU.CST) os is loading ...
```
### 2.问题答案
1.RISCV加电后的指令从*0x1000*到*0x1010*。  
2.指令完成的功能：
- `auipc t0,0x0`：**将高位立即数加到 PC**，该指令将当前程序计数器（PC，即 0x1000）加上一个 0x0≪12 的偏移量，结果存储到寄存器 t0 中。

- `addi a1,t0,32`：**立即数加法**，将t0加上32，结果存入寄存器 a1。

- `csrr a0,mhartid`：**控制和状态寄存器读取**，从 mhartid 寄存器读取当前核（hart）的 ID 存入 a0。

- `ld t0,24(t0)`：**加载双字**，从t0+24地址处读取8个字节，存入寄存器t0。

- `jr t0`：**寄存器跳转**，执行一个无条件跳转，目标地址是寄存器 t0 中存储的值。
