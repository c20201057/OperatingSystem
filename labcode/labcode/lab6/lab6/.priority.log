
OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
(THU.CST) os is loading ...

Special kernel symbols:
  entry  0xc020004a (virtual)
  etext  0xc0205a38 (virtual)
  edata  0xc02b15f8 (virtual)
  end    0xc02b5ae0 (virtual)
Kernel executable memory footprint: 727KB
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
memory management: default_pmm_manager
physcial memory map:
  memory: 0x08000000, [0x80000000, 0x87ffffff].
vapaofset is 18446744070488326144
check_alloc_page() succeeded!
check_pgdir() succeeded!
check_boot_pgdir() succeeded!
use SLOB allocator
kmalloc_init() succeeded!
check_vma_struct() succeeded!
check_vmm() succeeded.
sched class: RR_scheduler
++ setup timer interrupts
proc_run: switch from pid=0 to pid=1, next.pgdir=0x8020b000
proc_run: switch from pid=1 to pid=2, next.pgdir=0x8020b000
kernel_execve: pid = 2, name = "priority".
set priority to 6
main: fork ok,now need to wait pids.
proc_run: switch from pid=2 to pid=3, next.pgdir=0x804c9000
set priority to 1
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
set priority to 2
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
set priority to 3
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
set priority to 4
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
set priority to 5
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
100 ticks
End of Test.
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
proc_run: switch from pid=6 to pid=7, next.pgdir=0x804fd000
proc_run: returned to pid=7
100 ticks
End of Test.
child pid 7, acc 1156000, time 2010
proc_run: switch from pid=7 to pid=3, next.pgdir=0x804c9000
proc_run: returned to pid=3
child pid 3, acc 1216000, time 2020
proc_run: switch from pid=3 to pid=4, next.pgdir=0x804d6000
proc_run: returned to pid=4
child pid 4, acc 1276000, time 2030
proc_run: switch from pid=4 to pid=5, next.pgdir=0x804e3000
proc_run: returned to pid=5
child pid 5, acc 1268000, time 2040
proc_run: switch from pid=5 to pid=6, next.pgdir=0x804f0000
proc_run: returned to pid=6
child pid 6, acc 1260000, time 2050
proc_run: switch from pid=6 to pid=2, next.pgdir=0x804bc000
proc_run: returned to pid=2
main: pid 0, acc 1216000, time 2060
main: pid 4, acc 1276000, time 2060
main: pid 5, acc 1268000, time 2060
main: pid 6, acc 1260000, time 2070
main: pid 7, acc 1156000, time 2080
main: wait pids over
sched result: 1 1 1 1 1
proc_run: switch from pid=2 to pid=1, next.pgdir=0x8020b000
proc_run: returned to pid=1
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:468:
    initproc exit.

